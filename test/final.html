<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Simple Dimple</title>
</head>
<body>

<div style="display: flex; gap: 20px">
<div style="display: flex; gap: 20px; flex-direction: column">
    <div id="filters"></div>
    <div id="sorters"></div>
    <div id="chartSelectors">
    </div>
    <div style="display: flex; justify-content: center;">
        <button id="build">Build</button>
    </div>
</div>

<svg id="chart"  ></svg>
</div>
<div id="content">
    <table style="width: 50%">
        <thead>
        <td>Date</td>
        <td>Branch</td>
        <td>City</td>
        <td>Customer_type</td>
        <td>Gender</td>
        <td>Product_line</td>
        <td>Total</td>
        </thead>
        <tbody>
        </tbody>
    </table>
</div>

<script type="module">
    import * as d3 from 'https://cdn.jsdelivr.net/npm/d3@7/+esm'

    const FILTERED_FIELDS = ['Branch', 'City', 'Customer_type', 'Gender', 'Product_line', 'Date']
    const SORTED_FIELDS = ['Branch', 'City', 'Customer_type', 'Gender', 'Product_line', 'Date']//['','Date']
    const CHART_DATA_SHOW = ['Branch', 'City', 'Customer_type', 'Gender', 'Product_line']
    const CHART_SELECTOR = 'ChartSelector'
    const FILTER = 'Filter'
    const SORTER = 'Sorter'
    const DATA_PATH = './data/supermarket_sales.csv'

    // utils
    const groupDataByField = (data, fieldName) => d3.group(data, item => item[fieldName])

    const sortBy = (field, reverse) => {
        const key = x => x[field]
        reverse = [-1, 1][+!!reverse]
        return (a, b) => {
            a = key(a)
            b = key(b)
            return a == b ? 0 : reverse * ((a > b) - (b > a))
        }
    }

    const chainSortBy = sortByArray => {
        return (a, b) => {
            for (let i = 0; i < sortByArray.length; i++) {
                const res = sortByArray[i](a, b)
                if (res != 0) {
                    return res
                }
            }
            return 0
        }
    }

    const fillTable = data => {
        d3.select('#content tbody')
            .selectAll('tr')
            .data(data)
            .join('tr')
            .html((row) => `<tr>
      <td>${row.Date}</td>
        <td>${row.Branch}</td>
        <td>${row.City}</td>
        <td>${row.Customer_type}</td>
        <td>${row.Gender}</td>
        <td>${row.Product_line}</td>
        <td>${row.Total}</td>
  </tr>`)
    }

    const makeSortersMovable = () => {
        const list = document.getElementById("sorters")

        list.addEventListener("click", (e) => {
            const target = e.target
            if (target.tagName === "BUTTON") {
                const selectedItem = target.parentNode
                if (target.classList.contains("up-button")) {
                    if (selectedItem.previousElementSibling) {
                        selectedItem.parentNode.insertBefore(selectedItem, selectedItem.previousElementSibling)
                    }
                } else if (target.classList.contains("down-button")) {
                    if (selectedItem.nextElementSibling) {
                        selectedItem.parentNode.insertBefore(selectedItem.nextElementSibling, selectedItem)
                    }
                }
            }
        })
    }

    const buildButtonCallback = () => {
        const filters = getAllFilters()
        console.log(filters)
        let resultData = Array.from(data)

        for (const filter of filters) {
            let selectedOptions = []
            console.log(filter.value)
            selectedOptions.push(filter.value)
            if (selectedOptions.length > 0) {
                resultData = resultData.filter(
                    item => selectedOptions.includes(item[filter.id.replace(FILTER, '')]))
            }
            console.log(selectedOptions)
        }

        resultData = resultData.sort(getSortsData())

        fillTable(resultData)
        drawChart(resultData)
    }

    const makeBuildButton = () => {
        document.getElementById('build').addEventListener('click', buildButtonCallback)
    }

    const getData = async () => await d3.csv(DATA_PATH, res => {
        res.Date = new Date(res.Date).toLocaleDateString("fr-CA")
        return res
    })

    // filters
    // const FILTER_SUFFIX = 'Filter';


    const getAllFilters = () => {
        let filters = [];
        for (const filterName of FILTERED_FIELDS) {
            const filterInput = document.getElementById(filterName + FILTER + '-input'); // Получаем input элемент
            filters.push(filterInput);
        }
        return filters;
    }


    const initFilterHtml = filterName => {
        const filterId = filterName + FILTER;
        return `<input list="${filterId}" id="${filterId}-input" placeholder="Search ${filterName}...">
            <datalist id="${filterId}"></datalist>`;
    }

    const initFiltersHtml = () => {
        const filtersDiv = document.getElementById('filters');
        filtersDiv.innerHTML = `<h2>Фильтры</h2>`; // Используйте присваивание для очистки предыдущего содержимого
        FILTERED_FIELDS.forEach(filteredFieldName => {
            filtersDiv.innerHTML += initFilterHtml(filteredFieldName);
        });
    }

    const fillFilter = (data, filterName) => {
        const filterId = filterName + FILTER;
        d3.select('#' + filterId)
            .selectAll('option')
            .data(data)
            .join('option')
            .attr('value', data => data);
    }

    const fillAllFilters = data => {
        FILTERED_FIELDS.forEach(filterName => {
            const keys = groupDataByField(data, filterName).keys().toArray().sort();
            fillFilter(keys, filterName);
        });
    }


    // chart selectors
    const initChartSelectorsHtml = () => {
        const chartSelectorsDiv = document.getElementById('chartSelectors')
        chartSelectorsDiv.innerHTML += `<h2>Настройки</h2>`
        chartSelectorsDiv.innerHTML += `<h3>Поле группировки</h3>`
        chartSelectorsDiv.innerHTML +=
            `<select name="${CHART_SELECTOR}" id="${CHART_SELECTOR}"></select>`
        chartSelectorsDiv.innerHTML += `<h3>Аггрегирующая функция</h3>`
        chartSelectorsDiv.innerHTML +=
            `<select name="${CHART_SELECTOR + 'Aggregation'}" id="${CHART_SELECTOR + 'Aggregation'}">
           <option value="sum">sum</option>
           <option value="mean">mean</option>
           <option value="min">min</option>
           <option value="max">max</option>
         </select>`
        fillSelector(CHART_DATA_SHOW, CHART_SELECTOR)
    }

    const fillSelector = (data, chartSelectorId) => {
        d3.select('#' + chartSelectorId)
            .selectAll('option')
            .data(data)
            .join('option')
            .html(data => `<option value="${data}">${data}</option>`)
    }

    // sorts
    const initSorterHtml = sorterName => {
        const sorterId = sorterName + SORTER
        return `<div id="${sorterId}">
              <button class="up-button">↑</button>
              <button class="down-button">↓</button>
              <span>Sort by ${sorterName}</span>
              <input type="radio" id="${sorterId}Asc" name="${sorterName}" value="${sorterName}"/>
              <label for="${sorterId}Asc">Asc</label>
              <input type="radio" id="${sorterId}Desc" name="${sorterName}" value="${sorterName}" />
              <label for="${sorterId}Desc">Desc</label>
              <input type="radio" id="${sorterId}NS" name="${sorterName}" value="${sorterName}" checked/>
              <label for="${sorterId}NS">NS</label>
            </div>`
    }

    const initSortersHtml = () => {
        const sortsDiv = document.getElementById('sorters')
        sortsDiv.innerHTML += `<h2>Многоуровневая сортировка</h2>`
        SORTED_FIELDS.forEach(sortedFieldName => {
            sortsDiv.innerHTML += initSorterHtml(sortedFieldName)
        })
    }

    const getSortsData = () => {
        const sortsSequence = document.getElementById('sorters').children
        let sortData = []
        for (const sortsSequenceElement of sortsSequence) {
            const id = sortsSequenceElement.id
            if (!id) {
                continue
            }
            if (document.getElementById(id + 'Asc').checked) {
                sortData.push(sortBy(id.replace(SORTER, ''), true))
            } else if (document.getElementById(id + 'Desc').checked) {
                sortData.push(sortBy(id.replace(SORTER, ''), false))
            }
        }
        return chainSortBy(sortData)
    }

    // chart
    const drawChart = (data) => {
        const width = 1500
        const height = 1000
        const marginTop = 20
        const marginRight = 20
        const marginBottom = 30
        const marginLeft = 30
        const animationDuration = 3000

        const svg = d3.select('#chart')
            .attr('width', width)
            .attr('height', height)

        let resData = []

        let show = ''
        for (const option of document.getElementById(CHART_SELECTOR).options) {
            if (option.selected) {
                show = option.value
            }
        }

        let aggregation = ''
        for (const option of document.getElementById(CHART_SELECTOR + 'Aggregation').options) {
            if (option.selected) {
                aggregation = option.value
            }
        }

        const groupX = d3.group(data, d => d.Date)
        const axesXData = groupX.keys()
        for (const axesXItem of axesXData) {
            const groupY = d3.group(groupX.get(axesXItem), d => d[show])
            const axesYData = groupY.keys()
            for (const axesYItem of axesYData) {
                const viewData = d3[aggregation](groupY.get(axesYItem), d => +d.Total)
                resData.push({axesXItem, axesYItem, viewData})
            }
        }

        const xScale = d3.scaleBand()
            .domain(d3.group(resData, d => d.axesXItem).keys())
            .range([marginLeft, width - marginRight])
            .padding(1)

        const yScale = d3.scaleLinear()
            .domain(d3.extent(resData, d => d.viewData))
            .range([height - marginBottom, marginTop])

        // отрисованная ось x
        d3.select('#chart').selectAll('g.x-axis')
            .data([0]) // Используем массив из одного элемента, чтобы обеспечить создание или обновление одного элемента 'g.x-axis'
            .join(
                enter => enter.append('g') // Добавление нового элемента, если он отсутствует
                    .attr('class', 'x-axis')
                    .attr('transform', `translate(0,${height - marginBottom})`)
                    .call(d3.axisBottom(xScale)) // Инициализируем ось X
                    .selectAll("text")
                    .attr("transform", "rotate(-20)")
                    .style("text-anchor", "end"),
                update => update // Обновление существующего элемента
                    .call(g => g.transition() // Добавляем анимацию для обновления
                        .duration(animationDuration)
                        .attr('transform', `translate(0,${height - marginBottom})`)
                        .call(d3.axisBottom(xScale))) // Обновляем ось X
            );

        // отрисованная ось y

        d3.select('#chart').selectAll('g.y-axis')
            .data([0]) // Используем массив из одного элемента, чтобы обеспечить создание или обновление одного элемента 'g.y-axis'
            .join(
                enter => enter.append('g') // Добавление нового элемента, если он отсутствует
                    .attr('class', 'y-axis')
                    .attr('transform', `translate(${marginLeft},0)`),
                update => update // Обновление существующего элемента
            )
            .call(d3.axisLeft(yScale)) // Применяем ось Y ко всем элементам, как к новым, так и к обновленным
            .attr('transform', `translate(${marginLeft},0)`) // Обновляем положение оси
            .transition()
            .duration(animationDuration);

        function makeXGridlines() {
            return d3.axisBottom(xScale)
                .tickSize(-height + marginTop + marginBottom)
                .tickFormat("")
        }

        function makeYGridlines() {
            return d3.axisLeft(yScale)
                .tickSize(-width + marginLeft + marginRight)
                .tickFormat("")
        }

        if (d3.select('.x-grid').empty()) {
            // Добавление сетки оси X
            svg.append("g")
                .attr("class", "x-grid")
                .attr("transform", `translate(0,${height - marginBottom})`)
                .call(makeXGridlines())
                .selectAll('.tick line')
                .attr('stroke-opacity', 0.1)


            // Добавление сетки оси Y
            svg.append("g")
                .attr("class", "y-grid")
                .attr("transform", `translate(${marginLeft},0)`)
                .call(makeYGridlines())
                .selectAll('.tick line')
                .attr('stroke-opacity', 0.1)
        } else {
            updateGrid()
        }

        function updateGrid() {
            svg.select(".x-grid")
                .transition()
                .duration(animationDuration)
                .call(makeXGridlines())
                .selectAll('.tick line')
                .attr('stroke-opacity', 0.1)

            svg.select(".y-grid")
                .transition()
                .duration(animationDuration)
                .call(makeYGridlines())
                .selectAll('.tick line')
                .attr('stroke-opacity', 0.1)
        }

        const points = resData.map((d) => [xScale(d.axesXItem), yScale(d.viewData), d.axesYItem])
        const groups = d3.rollup(points, v => Object.assign(v, {z: v[0][2]}), d => d[2])
        console.log(points, groups)
        // отрисованные линии
        const line = d3.line()
        let path
        let legend
        let colors = ["red", "orange", "yellow", "green", "blue", "indigo", "violet"];
        let keys = Array.from(groups.keys()); // Преобразование Iterator в массив
        let colorsPaired = colors.map((color, index) => {
            return [color, keys[index]];
        }).filter(pair => pair[1] !== undefined);

        console.log(colorsPaired);
        if (d3.select('#chart g.lines').empty()) {

            // Функция, которая будет возвращать цвет для каждой линии
            let colorScale = d3.scaleOrdinal()
                .domain(d3.range(groups.length))
                .range(colors);

            path = svg.append("g")
                .attr("class", "lines")
                .attr("fill", "none")
                // .attr("stroke", "steelblue")
                .attr("stroke-width", 1.5)
                .attr("stroke-linejoin", "round")
                .attr("stroke-linecap", "round")
                .selectAll("path")
                .data(groups.values())
                .join("path")
                .style("mix-blend-mode", "multiply")
                .attr("d", line)
                .attr("stroke", function(d, i) {
                    return colorScale(i); // Использование функции colorScale для получения цвета для каждой линии
                })
             legend = svg.selectAll(".legend")
                .data(colorsPaired)
                .enter().append("g")
                .attr("class", "legend")
                .attr("transform", function(d, i) {
                    console.log(i)
                    console.log(`translate(${width - 100}, ${i * 20 + 100})`)
                    return `translate(${width - 100}, ${i * 20 + 100})`;
                });

// Добавление прямоугольника для каждого цвета в легенде
            legend.append("rect")
                .attr("width", 18)
                .attr("height", 18)
                .style("fill", function(d) { return d[0]; });

// Добавление текста для каждого цвета в легенде
            legend.append("text")
                .attr("x", 24)
                .attr("y", 9)
                .attr("dy", ".35em")
                .style("text-anchor", "start")
                .text(function(d) {
                    console.log(d)
                    return d[1];
                });
        } else {
            path = d3.select('#chart g.lines')
                .selectAll("path")
                .data(groups.values())
                .join(
                    enter => enter.append("path")
                        .attr("class", "line")
                        .attr("fill", "none")
                        .attr("stroke", "steelblue")
                        .attr("stroke-width", 1.5)
                        .attr("stroke-linejoin", "round")
                        .attr("stroke-linecap", "round")
                        .style("mix-blend-mode", "multiply")
                        .attr("d", line)
                        .call(enter => enter.transition().duration(animationDuration).attr("d", line)),
                    update => update.call(
                        update => update.transition().duration(animationDuration).attr("d", line)),
                    exit => exit.transition().duration(animationDuration).remove()
                )
            svg.selectAll(".legend").remove()
            legend = svg.selectAll(".legend")
                .data(colorsPaired)
                .enter().append("g")
                .attr("class", "legend")
                .attr("transform", function(d, i) {
                    console.log(i)
                    console.log(`translate(${width - 250}, ${i * 20 + 100})`)
                    return `translate(${width - 250}, ${i * 20 + 100})`;
                });

// Добавление прямоугольника для каждого цвета в легенде
            legend.append("rect")
                .attr("width", 18)
                .attr("height", 18)
                .style("fill", function(d) { return d[0]; });

// Добавление текста для каждого цвета в легенде
            legend.append("text")
                .attr("x", 24)
                .attr("y", 9)
                .attr("dy", ".35em")
                .style("text-anchor", "start")
                .text(function(d) {
                    console.log(d)
                    return d[1];
                });
        }

        const dot = svg.append("g")
            .attr("display", "none")

        dot.append("circle")
            .attr("r", 2.5)

        dot.append("text")
            .attr("text-anchor", "middle")
            .attr("y", -8)

        svg
            .on("touchstart", event => event.preventDefault())
    }

    // main
    const data = await getData()

    initFiltersHtml()
    fillAllFilters(data)
    initSortersHtml()
    initChartSelectorsHtml()
    makeSortersMovable()

    fillTable(data)
    makeBuildButton()
    buildButtonCallback()
</script>
</body>
</html>